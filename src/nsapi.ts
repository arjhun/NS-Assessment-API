import "dotenv/config"
import createClient from "openapi-fetch"
import type { components, paths } from "./types/reisinformatie" // generated by openapi-typescript for type safety

type Trip = components["schemas"]["Trip"]
type TripRequest = {
  fromStation: string
  toStation: string
  dateTime?: string
}
const client = createClient<paths>({
  baseUrl: "https://gateway.apiportal.ns.nl/reisinformatie-api",
  headers: { "Ocp-Apim-Subscription-Key": process.env.APIKEY }, // https://apiportal.ns.nl/startersguide how to get your key
})

// middleware for debugging requests

client.use({
  onRequest: ({ request }) => {
    if (process.env.NODE_ENV !== "production") console.log(request)
    return request
  },
})

const BUSY_WEIGHT = 1,
  TRANSFER_WEIGHT = 1,
  FACILITY_WEIGHT = 1

//give a score of max 3 to how busy the trip is forcasted to be
export const getCrowdScore = (score?: Trip["crowdForecast"]) => {
  switch (score) {
    case "LOW":
      return 3
    case "MEDIUM":
      return 2
    case "HIGH":
      return 1
    default:
      return 0
  }
}

//find a journey by id
const getJourneyDetailById = async (
  id: string,
  train?: number,
  dateTime?: string
) => {
  const { data, error } = await client.GET("/api/v2/journey", {
    params: {
      query: {
        id,
        train,
        dateTime,
      },
    },
  })
  return data
}

// score a trip based on comfort higher is better
const getComfortScore = async (trip: Trip): Promise<number> => {
  const facilitiesOnJourney = new Set<string>()
  // loop through each journey to find all the facilities present in train,
  // adding all the facilities to a set to get a list of all the facilities present
  for (const leg of trip.legs) {
    if (!leg.journeyDetailRef) continue
    // a journey is a separete api request
    const journey = await getJourneyDetailById(
      leg.journeyDetailRef,
      Number(leg.product?.number),
      leg.origin.plannedDateTime
    )
    // this part of the api is a little unclear to me
    // (but it was the only part that mentioned facilities)
    // should I add a dateTime to getJourneyDetail?
    journey?.payload.stops?.forEach((stop) => {
      const stock = stop.actualStock ?? stop.plannedStock
      stock?.trainParts.forEach((part) => {
        part.facilities.forEach((facility) => {
          facilitiesOnJourney.add(facility)
        })
      })
    })
  }
  //add a weight to the scores
  const busyScore = getCrowdScore(trip.crowdForecast) * BUSY_WEIGHT
  const facilityScore = facilitiesOnJourney.size * FACILITY_WEIGHT
  const transferScore = trip.transfers * TRANSFER_WEIGHT
  //return the score, transfers are deducted
  return busyScore + facilityScore - transferScore
}

export const getTrips = async ({
  fromStation,
  toStation,
  dateTime,
}: TripRequest): Promise<Trip[] | undefined> => {
  const { data, error } = await client.GET("/api/v3/trips", {
    params: {
      query: {
        fromStation: fromStation,
        toStation: toStation,
        //default to now
        dateTime: dateTime || new Date().toISOString(),
        //only search around departure time
        searchForArrival: false,
        //only actual stops!
        passing: false,
      },
    },
    middleware: {},
  })

  if (error) {
    console.error(error)
    throw new Error(error.message)
  }
  return data?.trips
}

export const findOptimalTrip = async ({
  fromStation,
  toStation,
  dateTime,
}: TripRequest) => {
  const trips = await getTrips({ fromStation, toStation, dateTime })
  return trips?.find((trip) => trip.optimal)
}

export const getTripsByComfort = async ({
  fromStation,
  toStation,
  dateTime,
}: TripRequest) => {
  const trips = await getTrips({ fromStation, toStation, dateTime })
  if (!trips) return
  return await Promise.all(
    trips.map(async (trip) => ({
      trip,
      // add score so we can sort adter all promises are done
      score: await getComfortScore(trip),
    }))
  ).then((scoredTrips) =>
    scoredTrips
      .sort((a, b) => a.score - b.score)
      // remove score
      .map((scoredTrip) => scoredTrip.trip)
  )
}
